{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Writeups","text":"<p>Hi there! This is a place for my personal CTF writeups.</p>"},{"location":"2025/FMCTF%201404/crypto/EZ_XOR/","title":"EZ XOR","text":""},{"location":"2025/FMCTF%201404/crypto/EZ_XOR/#challenge","title":"Challenge","text":"<p>We are given this python script: EZ_XOR.py<pre><code>from pwn import *\nFLAG = os.environ.get(\"FLAG\", \"FMCTF{F4K3_FL49}\").encode()\nkey = os.urandom(7)\nencryptedFlag = xor(FLAG, key).hex()\nprint(f\"encryptedFlag = {encryptedFlag}\")\n# encryptedFlag = a850d725cb56b0de4fcb40de72a4df56a72ec06cafa75ecb41f51c95\n</code></pre></p>"},{"location":"2025/FMCTF%201404/crypto/EZ_XOR/#solve","title":"Solve","text":"<p>Knowing the flag format, we xor the known characters to get the key, and xor the key with the ciphered text to get the flag <pre><code>from pwn import *\ns = bytes.fromhex(\"a850d725cb56b0de4fcb40de72a4df56a72ec06cafa75ecb41f51c95\")\nkey = xor(b'FMCTF{', s[:6]) + xor(b'}', s[-1])\nprint(xor(s, key))\n</code></pre></p> Flag <p>FMCTF{X0R_1S_L1K3_MAGIC_0x1}</p>"},{"location":"2025/FMCTF%201404/reverse/","title":"olleH","text":""},{"location":"2025/FMCTF%201404/reverse/#challenge","title":"Challenge","text":"<p> We're given a binary file called olleH. </p>"},{"location":"2025/FMCTF%201404/reverse/#solve","title":"Solve","text":"<p>I used Ghidra to decompile the binary, here's the main part: <pre><code>undefined8 main(void){\n  bool bVar1;\n  size_t sVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  int local_b8;\n  int local_b0;\n  byte local_9f [39];\n  byte local_78 [104];\n  long local_10;\n\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_9f[0] = 0x4e;\n  local_9f[1] = 0x6f;\n  local_9f[2] = 0x77;\n  local_9f[3] = 0x72;\n  local_9f[4] = 0x75;\n  local_9f[5] = 0x7a;\n  local_9f[6] = 0;\n  local_9f[7] = 8;\n  local_9f[8] = 0x22;\n  local_9f[9] = 0x34;\n  local_9f[10] = 0x26;\n  local_9f[0xb] = 0x33;\n  local_9f[0xc] = 1;\n  local_9f[0xd] = 6;\n  local_9f[0xe] = 0x5c;\n  local_9f[0xf] = 0x1b;\n  local_9f[0x10] = 0x1e;\n  local_9f[0x11] = 0x45;\n  local_9f[0x12] = 0x25;\n  local_9f[0x13] = 0x3c;\n  local_9f[0x14] = 0x5c;\n  local_9f[0x15] = 1;\n  local_9f[0x16] = 0x41;\n  local_9f[0x17] = 7;\n  local_9f[0x18] = 9;\n  local_9f[0x19] = 0x7d;\n  local_9f[0x1a] = 0x30;\n  local_9f[0x1b] = 0x44;\n  local_9f[0x1c] = 0x1c;\n  local_9f[0x1d] = 0x12;\n  local_9f[0x1e] = 0x25;\n  local_9f[0x1f] = 0x7e;\n  local_9f[0x20] = 0x17;\n  local_9f[0x21] = 0x42;\n  local_9f[0x22] = 0x45;\n  local_9f[0x23] = 0x16;\n  local_9f[0x24] = 7;\n  sVar2 = strlen((char *)local_9f);\n  printf(\"Enter your flag: \");\n  __isoc99_scanf(&amp;DAT_0010201a,local_78);\n  sVar3 = strlen((char *)local_78);\n  if ((int)sVar3 == 0x1e) {\n    for (local_b8 = 0; local_b8 &lt; 0x1e; local_b8 = local_b8 + 1) {\n      local_78[local_b8] = local_78[local_b8] ^ local_9f[local_b8 % (int)sVar2];\n    }\n    bVar1 = true;\n    for (local_b0 = 0; local_b0 &lt; 0x1e; local_b0 = local_b0 + 1) {\n      if (local_78[local_b0] != local_9f[(long)local_b0 + 7]) {\n        bVar1 = false;\n        break;\n      }\n    }\n    if (bVar1) {\n      puts(\"Victory! You found the correct flag!\");\n    }\n    else {\n      puts(\"Try again!\");\n    }\n  }\n  else {\n    printf(\"Try again! (Flag length should be %d characters)\\n\",0x1e);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    // WARNING: Subroutine does not return\n  __stack_chk_fail();\n}\n</code></pre> Using the c program below I was able to figure out the value of local_9f variable, which is \"nowruz\", and by reversing the proccess done in the original code, I got the flag: <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n    int local_9f[39];\n    local_9f[0] = 0x4e;\n    local_9f[1] = 0x6f;\n    local_9f[2] = 0x77;\n    local_9f[3] = 0x72;\n    local_9f[4] = 0x75;\n    local_9f[5] = 0x7a;\n    local_9f[6] = 0;\n    local_9f[7] = 8;\n    local_9f[8] = 0x22;\n    local_9f[9] = 0x34;\n    local_9f[10] = 0x26;\n    local_9f[0xb] = 0x33;\n    local_9f[0xc] = 1;\n    local_9f[0xd] = 6;\n    local_9f[0xe] = 0x5c;\n    local_9f[0xf] = 0x1b;\n    local_9f[0x10] = 0x1e;\n    local_9f[0x11] = 0x45;\n    local_9f[0x12] = 0x25;\n    local_9f[0x13] = 0x3c;\n    local_9f[0x14] = 0x5c;\n    local_9f[0x15] = 1;\n    local_9f[0x16] = 0x41;\n    local_9f[0x17] = 7;\n    local_9f[0x18] = 9;\n    local_9f[0x19] = 0x7d;\n    local_9f[0x1a] = 0x30;\n    local_9f[0x1b] = 0x44;\n    local_9f[0x1c] = 0x1c;\n    local_9f[0x1d] = 0x12;\n    local_9f[0x1e] = 0x25;\n    local_9f[0x1f] = 0x7e;\n    local_9f[0x20] = 0x17;\n    local_9f[0x21] = 0x42;\n    local_9f[0x22] = 0x45;\n    local_9f[0x23] = 0x16;\n    local_9f[0x24] = 7;\n\n    char guess[31]; guess[30] = '\\0';\n    for(int i = 0; i &lt; 30; i++)\n        guess[i] = local_9f[i + 7];\n\n    for(int i = 0; i &lt; 30; i++)\n        guess[i] = guess[i] ^ local_9f[i % 6];\n\n    cout &lt;&lt; guess;\n}\n</code></pre></p> Flag <p>FMCTF{H3ll0_r3v3rs3_3ng_0x57c}</p>"}]}